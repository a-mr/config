scriptencoding utf-8
set encoding=utf-8
set nocompatible
"use mouse in terminal
"set mouse=a

set nofixendofline

" always let some lines after cursor
set scrolloff=10
" 'start' to fix backspace on some systems
set backspace=indent,start
" 'eol' to allow delete new line
"set backspace=indent,eol,start

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"common settings
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

if has("autocmd")
  filetype indent on
endif
filetype plugin on
set smartindent

" execute pathogen#infect()

" allow switching buffers without saving
set hidden
"set number
set showcmd

set backup
set backupdir=~/tmp/VIM_TMP//,.
set directory=~/tmp/VIM_TMP//,.
set   undodir=~/tmp/VIM_TMP//,.
" Use Ctrl-C/Ctrl-V clipboard (NOT selection/S-Insert) for y/p operations:
"set clipboard=unnamedplus
"disable copy/paste to system clipboard
set clipboard=
"set clipboard+=unnamed

" Tell vim to remember certain things when we exit
"  !    :  save and restore global variables (for vim-mark plugin)
"  '10  :  marks will be remembered for up to 10 previously edited files
"  "100 :  will save up to 100 lines for each register
"  :200 :  up to 200 lines of command-line history will be remembered
"  %    :  saves and restores the buffer list
"  n... :  where to save the viminfo files
set viminfo=!,'10,\"100,:200,%,n~/.viminfo
set history=200

set nowrapscan
set ignorecase

"allows use vim as pager
let $PAGER=''

if &term == "screen"
    set t_ts=k
    set t_fs=\
endif
if &term == "screen.xterm-256color"
    set t_ts=k
    set t_fs=\
endif

" jump to the last position when reopening a file
if has("autocmd")
   au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif
endif

function! SearchMultiLine(bang, ...)
  if a:0 > 0
    let sep = (a:bang) ? '\_W\+' : '\_s\+'
    let @/ = join(a:000, sep)
  endif
endfunction
command! -bang -nargs=* -complete=tag S call SearchMultiLine(<bang>0, <f-args>)|normal! /<C-R>/<CR>

" IMPORTANT: grep will sometimes skip displaying the file name if you
" search in a singe file. This will confuse Latex-Suite. Set your grep
" program to always generate a file-name.
set grepprg=nimgrep\ --text\ --recursive\ --excludeDir=.git\ --excludeDir=.svn\ --excludeDir=.hg\ --excludeDir=nimcache\ --excludeDir:csources\ $*\ .
"set grepprg=grep\ -rnH\ --exclude-dir=.git\ --exclude-dir=.svn\ --exclude-dir=.hg\ $*\ .
command! -nargs=+ Grep  execute 'silent grep! <args>'    | copen | let @z = '<args>'
command! -nargs=+ Grepw execute 'silent grep! -w <args>' | copen | let @z = '<args>'
"| execute 'silent /<args>'

map <S-F12> "zyiw:grep "<C-R>z"<CR><CR>:copen<CR>zz/<C-R>z<CR>
map <Leader>g "zyiw:grep "<C-R>z"<CR><CR>:copen<CR>zz/<C-R>z<CR>
vmap <S-F12> "zy:grep "<C-R>z"<CR><CR>zz/<C-R>z<CR>
map <F12> :cn<CR>zz/<C-R>z<CR>
map <C-F12> :cp<CR>zz/<C-R>z<CR>

set virtualedit=all                         " Allow jump & move blocks over EOL
" jump for the specified column to make comments
let Comment="#"
au! BufRead,BufNewFile *.nim,*.nims,*.sh,*.tcl,*.php,*.pl,*.py let Comment="#"
au! BufRead,BufNewFile .bashrc,.bash_profile,.profile let Comment="#"
au! BufRead,BufNewFile *.c,*.h,*.cpp,*.cxx,*hpp,*hxx let Comment="//"
au! BufRead,BufNewFile .vimrc,*.vim let Comment="\""
au! BufRead,BufNewFile *.tex let Comment="%"

nnoremap c :call SideComment()<CR>a
inoremap c <ESC>:call SideComment()<CR>a
function! SideComment()
    normal 45|
    "don't put space after # (to be able to add second #)
    exe ":normal i" . g:Comment
    "exe ":normal i" . g:Comment . "\ "
endfunction

" comment out line(s) from the beginning
function! CommentLines()
    exe ":s/^\\( *\\)/\\1" . escape(g:Comment, '/') . "\ "
endfunction
vnoremap z :call CommentLines()<CR>
nnoremap z :call CommentLines()<CR>
inoremap z <ESC>:call CommentLines()<CR>

" comments in C files
nmap <Leader>c _i/* <Esc>A */<Esc>

"hi CursorColumn cterm=NONE ctermbg=darkgray ctermfg=white guibg=darkgray guifg=white
"nnoremap <Leader>c :set cursorline! cursorcolumn!<CR>
nnoremap <Leader>v :set cursorline!<CR>

augroup BgHighlight
    autocmd!
    autocmd WinEnter * call HighlightWindow()
    autocmd WinLeave * call UnHighlightWindow()
augroup END

"colorcolumn breaks copy-paste adding spaces
function! HighlightWindow()
    set cursorline
    "if v:version > 703
    "    set colorcolumn=80
    "endif
endfunction

"hi ColorColumn cterm=underline ctermbg=None
call HighlightWindow()
function! UnHighlightWindow()
    set nocursorline
    "if v:version > 703
    "    set colorcolumn=0
    "endif
endfunction

"highlight search
set hlsearch
"set encoding=koi8-r
"set termencoding=koi8-r
"√≠√Ö√é√Ä √ã√è√Ñ√â√í√è√ó√è√ã
set wildmenu
set wcm=<Tab>
menu Encoding.windows-1251 :e ++enc=8bit-cp1251<CR>
menu Encoding.utf-8        :e ++enc=utf-8<CR>
menu Encoding.ibm-866      :e ++enc=8bit-cp866<CR>
menu Encoding.koi8-r       :e ++enc=koi8-r<CR>
menu SetSpell.off :set nospell<CR>
menu SetSpell.ru  :set spl=ru spell<CR>
menu SetSpell.en  :set spl=en spell<CR>

"set spellfile=my1.utf-8.add
"setlocal spell spelllang=ru
"set spell spelllang=ru_yo
set spellfile=~/.vim/spell/my1.utf-8.add

" handle long lines in a smarter way
function! Setshowbreak()
    "set showbreak=\ \ ‚ï∞‚îÄ\ 
    if has('win32') && has('gui_running')
        set showbreak=\ \ \ \ \ ->\ 
    else
        "set showbreak=\ \ \ \ \ ‚Ü™\ 
        set showbreak=\ \ ‚ï∞‚îÄ\ \ 
    endif
    if v:version >= 800
        set breakindent
    endif
endfunction
call Setshowbreak()

function! UnSetshowbreak()
    set showbreak=
    if v:version >= 800
        set nobreakindent
    endif
endfunction

"try to show as much as possible of the last line in the window (rather than
"a column of "@", which is the default behavior).
set display+=lastline

hi NonText ctermfg=yellow

" enable soft wrapping at the edge of the screen
set wrap
" make it not wrap in the middle of a "word"
set linebreak
set breakat=\ ,(
"set breakindentopt=shift:4

set cpoptions+=n

"set sidescroll=5

"set helplang=ru

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"colors & statusline
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

"Gvim colorsheme
if has("gui_running")
	colorscheme pablo
endif

function! InsertStatuslineColor(mode)
  if a:mode == 'i'
    hi statusline guibg=Cyan ctermfg=Green guifg=Black ctermbg=Black
  elseif a:mode == 'r'
    hi statusline guibg=Purple ctermfg=Green guifg=Black ctermbg=Black
  else
    hi statusline guibg=DarkRed ctermfg=1 guifg=Black ctermbg=0
  endif
endfunction

au InsertEnter * call InsertStatuslineColor(v:insertmode)
au InsertLeave * hi statusline guibg=DarkGrey ctermfg=White guifg=White ctermbg=Black

" default the statusline to green when entering Vim
hi statusline guibg=DarkGrey ctermfg=8 guifg=White ctermbg=15

" Formats the statusline
set statusline=%f                           " file name
"set statusline+=[%{strlen(&fenc)?&fenc:'none'}, "file encoding
"set statusline+=%{&ff}] "file format
set statusline+=%y      "filetype
set statusline+=%h      "help file flag
"set statusline+=%m      "modified flag
set statusline+=%r      "read only flag

"" Puts in the current git status
"    if count(g:pathogen_disabled, 'Fugitive') < 1   
"        set statusline+=%{fugitive#statusline()}
"    endif
"
"" Puts in syntastic warnings
"    if count(g:pathogen_disabled, 'Syntastic') < 1  
"        set statusline+=%#warningmsg#
"        set statusline+=%{SyntasticStatuslineFlag()}
"        set statusline+=%*
"    endif

set statusline+=\ %=                        " align left
set statusline+=L:%l/%L            " line X of Y [percent of file]
set statusline+=\ C:%c%V                  " current column: actual+virtual
set statusline+=\ B#%n                    " Buffer number
"set statusline+=\ [%b][0x%B]\               " ASCII and byte code under cursor
set statusline+=\ [0x%B]\                   " byte code under cursor

""hi statusline guibg=DarkGrey ctermfg=8 guifg=White ctermbg=15
"hi statusline guibg=White ctermfg=8 guifg=DarkGrey ctermbg=15
"highlight LineNr ctermbg=darkgrey
"
"normal
hi User1 ctermbg=7 ctermfg=0
" red error
hi User2 ctermbg=0 ctermfg=1 
" green success
hi User3 ctermbg=7  ctermfg=2 
" yellow warnings
"doesn't work in gui mode?
hi User4 ctermbg=0  ctermfg=3 guibg=#ffffff guifg=#ffff00 cterm=bold 
"blue - questions
hi User5 ctermbg=7  ctermfg=4 
"bold white - important messages
hi User6 ctermbg=0  ctermfg=0 cterm=bold
"danger 
hi User7 ctermbg=0  ctermfg=1 cterm=bold
"auxillary
hi User8 ctermbg=7  ctermfg=6 
"bright
hi User9 cterm=bold
"use 'hi User9 none' to turn it off

set noruler
set laststatus=2

"set statusline=
"set statusline+=%1*\[%n]                                "buffernr
"set statusline+=%1*\ %<%f\                              "File+path
"set statusline+=%8*%y\                                  "FileType
"set statusline+=%8*%{''.(&fenc!=''?&fenc:&enc).''}      "Encoding
"set statusline+=%8*%{(&bomb?\",BOM\":\"\")}\            "Encoding2
"set statusline+=%8*%{&ff}\                              "FileFormat (dos/unix..) 
"set statusline+=%8*%{&spelllang}                        "Spellanguage 
"set statusline+=%1*%=\ %o\                              " space .. bytenumber
"set statusline+=%1*col:%v\                            "Colnr
""set statusline+=%1*col:%03c\                            "Colnr
"set statusline+=%1*line:%l/%L\                "Rownumber/total (%)
"
"set statusline+=\ \ %{noscrollbar#statusline(30,'-','\|')}%=
set statusline+=\ \ %{noscrollbar#statusline(25,'‚îÄ','‚ñ†')}%=
if !has("gui_running")
"set statusline+=%4*%m%2*%r%w%1*\ %P\                    "Modified? Readonly? Top/bot.
set statusline+=%P%4*%m%2*%r%w\                    "Modified? Readonly? Top/bot.
else
set statusline+=%P%m%r%w\                    "Modified? Readonly? Top/bot.
endif

command! -nargs=* Myhardcopy call DoMyPrint('<args>')
function DoMyPrint(args)
  let colorsave=g:colors_name
  color print
  exec 'hardcopy '.a:args
  exec 'color '.colorsave
endfunction

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Tab line
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" copied from https://superuser.com/a/477221
" Rename tabs to show tab number.
" (Based on http://stackoverflow.com/questions/5927952/whats-implementation-of-vims-default-tabline-function)
if exists("+showtabline")
    function! MyTabLine()
        let s = ''
        let wn = ''
        let t = tabpagenr()
        let i = 1
        while i <= tabpagenr('$')
            let buflist = tabpagebuflist(i)
            let winnr = tabpagewinnr(i)
            let s .= '%' . i . 'T'
            let s .= (i == t ? '%1*' : '%2*')
            " let s .= ' '
            let wn = tabpagewinnr(i,'$')

            let s .= '%#TabNum#'
            " let s .= i
            let s .= i . ':'
            " let s .= '%*'
            let s .= (i == t ? '%#TabLineSel#' : '%#TabLine#')
            let bufnr = buflist[winnr - 1]
            let file = bufname(bufnr)
            let buftype = getbufvar(bufnr, 'buftype')
            if buftype == 'nofile'
                if file =~ '\/.'
                    let file = substitute(file, '.*\/\ze.', '', '')
                endif
            else
                let file = fnamemodify(file, ':p:t')
            endif
            if file == ''
                let file = '[No Name]'
            endif
            "let s .= ' ' . file . ' '
            let s .= file . ' '
            let i = i + 1
        endwhile
        let s .= '%T%#TabLineFill#%='
        let s .= (tabpagenr('$') > 1 ? '%999XX' : 'X')
        return s
    endfunction
    set stal=2
    set tabline=%!MyTabLine()
    set showtabline=1
    highlight link TabNum Special
endif

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"common settings for programming
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

syntax on
" disable it for files > 10 MB
autocmd BufReadPre * if getfsize(expand("%")) > 10000000 | syntax off | endif
set ts=8
set shiftwidth=4
set softtabstop=4 "delete 4 spaces by backspace

" activate julia's latex->unicode completion
let g:latex_to_unicode_file_types = ["julia", "lisp", "tex", "latex"]
let g:latex_to_unicode_auto = 1

" no folding after file opening
set foldlevel=99

" enable Markdown folding
let g:markdown_folding = 1

" To use for files that have LSP support:
" set foldmethod=expr
"   \ foldexpr=lsp#ui#vim#folding#foldexpr()
"   \ foldtext=lsp#ui#vim#folding#foldtext()

" let's use indent for the most, and only adds exceptions for good
" clangd-based options:
set foldmethod=indent

highlight Folded ctermbg=NONE

"autocmd bufenter *.c,*.h,*.C,*.cxx,*.cpp,*.cc,*.hh,*.hxx,*.f,*.F,*.for set expandtab 
"autocmd bufenter *.py,*.hs,*.nim setlocal expandtab
"always expand tab:
set expandtab
autocmd bufenter *.nim setlocal syntax=nim
"autocmd bufenter *.py,*.hs setlocal indentexpr=
"autocmd bufenter *.py setlocal shiftwidth=4 softtabstop=4
set list
set listchars=tab:‚Åû\ 
"one may additionaly highlight tabs by the Grey color:
"hi SpecialKey ctermbg=Grey guibg=Grey
autocmd bufenter *.mlt set filetype=ocaml
" protobuf
autocmd bufenter *.proto set filetype=cpp
runtime macros/matchit.vim

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"EasyMotion config
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
hi link EasyMotionTarget WarningMsg

nmap s <Leader>

" go to word beginning
map sw <Plug>(easymotion-bd-w)
" go to word end
map se <Plug>(easymotion-bd-e)
" go to line
map sk <Plug>(easymotion-bd-jk)
" go to character
map sn <Plug>(easymotion-bd-f)

" Jump to anywhere with only `s{char}{target}`
" `s<CR>` repeat last find motion.
map <Leader>s <Plug>(easymotion-prefix)
" Use uppercase target labels and type as a lower case
let g:EasyMotion_use_upper = 1

"map <Leader>l <Plug>(easymotion-lineforward)
"map <Leader>j <Plug>(easymotion-j)
"map <Leader>k <Plug>(easymotion-k)
"map <Leader>h <Plug>(easymotion-linebackward)
let g:EasyMotion_keys = ",.'abcdfghijklmpqrtuvxyzswone"

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Start interactive EasyAlign in visual mode (e.g. vipga)
xmap ga <Plug>(EasyAlign)

" Start interactive EasyAlign for a motion/text object (e.g. gaip)
nmap ga <Plug>(EasyAlign)


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"key mappings: keys, shortcuts
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

imap <C-t> <Return>
cmap <C-t> <Return>
nmap <C-t> <C-f>
vmap <C-t> <C-f>
" in dvorus-layout `j` is placed at pinky, which creates too much stress on it
noremap t j
noremap j t

function! s:ConfigureNetrw()
    nnoremap <buffer> t j
    nnoremap <buffer> j t
    nmap <buffer> <C-t> <Return>
endfunction

augroup netrw_configuration
  autocmd!
  autocmd FileType netrw call s:ConfigureNetrw()
augroup end

" timeout for leader and other key combination is 1000 [ms]:
set timeout
set timeoutlen=1000

" Pressing <ESC>j in insert mode leads e.g. to accidental triggering of Alt-j.
" Escape to normal mode without triggering alt keys accidentaly:
imap e <ESC>:<CR>
map u $a
imap u <ESC>$a
map y ^i
imap y <ESC>^i

" basic editing: Alt-, to go to new line
imap , <ESC>^o
map , o
" Alt-; to put ; at the end of line and go to new line
imap ; <ESC>A;<CR>
map ; A;<CR>

" Alt-. printf
map . oprint("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ ", )<ESC>:<CR>i
au FileType c,cpp  map . oprintf<TAB>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ  
au FileType nim    map . oecho "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ 
au FileType sh     map . oecho "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ  " 
au FileType python map . oprint("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ ", )<ESC>:<CR>i
imap . <ESC>.

" save file by Ctrl-S
nmap <C-s> :w<Return>
imap <C-s> <ESC><C-s>

" close current window by Ctrl-q
nmap <C-q> :q<Return>
imap <C-q> <ESC><C-q>

nmap q :qa<CR>
imap q <Esc>:qa<CR>

" highlight the current line until `:call clearmatches()`
nnoremap <silent> <leader>l :call matchadd('Search', '\%'.line('.').'l')<cr>

" convenience shortcuts for copy/paste into CLIPBOARD (+) or PRIMARY (*)
nnoremap <C-C> "+yiw
vnoremap <C-C> "+y
nnoremap <C-J> "+p
inoremap <C-J> <ESC>:<CR>l"+pli

" Tab-related settings
set tabpagemax=20

nnoremap t :tabedit<Space>
inoremap t <Esc>:tabedit<Space>
nnoremap n :tabnext<CR>
inoremap n <Esc>:tabnext<CR>
nnoremap p :tabprev<CR>
inoremap p <Esc>:tabprev<CR>

" switch to last visited tab via A-o
if !exists('g:lasttab')
  let g:lasttab = 1
endif
nmap o :exe "tabn ".g:lasttab<CR>
imap o <Esc>o
au TabLeave * let g:lasttab = tabpagenr()

nnoremap 1 :tabnext 1<CR>
inoremap 1 <Esc>:tabnext 1<CR>
nnoremap 2 :tabnext 2<CR>
inoremap 2 <Esc>:tabnext 2<CR>
nnoremap 3 :tabnext 3<CR>
inoremap 3 <Esc>:tabnext 3<CR>
nnoremap 4 :tabnext 4<CR>
inoremap 4 <Esc>:tabnext 4<CR>
nnoremap 5 :tabnext 5<CR>
inoremap 5 <Esc>:tabnext 5<CR>
nnoremap 6 :tabnext 6<CR>
inoremap 6 <Esc>:tabnext 6<CR>
nnoremap 7 :tabnext 7<CR>
inoremap 7 <Esc>:tabnext 7<CR>
nnoremap 8 :tabnext 8<CR>
inoremap 8 <Esc>:tabnext 8<CR>
nnoremap 9 :tabnext 9<CR>
inoremap 9 <Esc>:tabnext 9<CR>
"nnoremap 0 :tabnext 10<CR>
"inoremap 0 <Esc>:tabnext 10<CR>
nnoremap 0 :vert sb
inoremap 0 <Esc>:vert sb

nnoremap b :tab ball<CR>
inoremap b <Esc>b

nmap ' ]'
imap ' <Esc>]'
" nmap q ['
" imap q <Esc>['
" version control
nmap j ]c
imap j <Esc>]c
nmap k [c
imap k <Esc>[c
"show latest committed version of this line
function! GitDiff()
    let diff_cmd = "git diff --color=never " . expand('%')
    rightbelow vnew
    setlocal buftype=nofile
    let diff_output = system(diff_cmd)
    call append(0, split(diff_output, "\n"))
    setlocal ft=diff
    "wincmd p
    "setlocal spell spelllang=en_us
endfunction
map x :call GitDiff()<CR>
imap x <ESC>x

nnoremap st <C-]>:tselect<CR>
vnoremap st <C-]>:tselect<CR>

if bufwinnr(1)
  map + <C-W>+
  map - <C-W>-
endif

"imap jj <Esc> 
"backspace fix:
set t_kb=

nmap <PageUp> <C-U><C-U>
imap <PageUp> <C-O><C-U><C-O><C-U>

nmap <PageDown> <C-D><C-D>
imap <PageDown> <C-O><C-D><C-O><C-D>

nmap <Space> i_<Esc>:<CR>r
"nmap <CR> o<Esc>

function! CapitalizeCenterAndMoveDown()
   s/./\u&/g   "Built-in substitution capitalizes each word
   center        "Built-in center command centers entire line
   +1            "Built-in relative motion (+1 line down)
endfunction

nmap <silent>  \C  :call CapitalizeCenterAndMoveDown()<CR>

function! TogglePaste()
   if &g:paste
      set nopaste 
      "set number
      call Setshowbreak()
      set list
      set linebreak
      call HighlightWindow()
   else
      set paste 
      set nonumber
      call UnSetshowbreak()
      set nolist
      set nolinebreak
      call UnHighlightWindow()
   endif
   SignatureToggle
   SignifyToggle
   " BUG in signify disable: adds an extra space after \
endfunction

function! ToggleSyntax()
   if exists("g:syntax_on")
      syntax off
   else
      syntax enable
   endif
endfunction

autocmd BufRead,BufNewFile * syn match mybraces /{\|}/
autocmd BufRead,BufNewFile * syn match mybrackets /\[\|\]/
autocmd BufRead,BufNewFile * syn match parens /(\|)/

highlight ExtraWhitespace ctermbg=red guibg=red
autocmd BufWinEnter * match ExtraWhitespace /\s\+$/

let g:parenColors = 1

function! ToggleParenColors()
   if g:parenColors
      hi mybraces cterm=bold ctermfg=blue guibg=#ffffff guifg=#ffff00
      hi mybrackets cterm=bold ctermfg=yellow
      hi parens cterm=bold
      let g:parenColors = 0
   else
      hi mybraces none
      hi mybrackets none
      hi parens none
      let g:parenColors = 1
   endif
endfunction

call ToggleParenColors()

let g:lsp_on = 1
function! ToggleLsp()
   if g:lsp_on
       call lsp#disable()
       let g:lsp_on = 0
       echo "lsp server disabled"
   else
       call lsp#enable()
       let g:lsp_on = 1
       echo "lsp server enabled"
   endif
endfunction

"my dvorus layout for russian
if has('win32') && has('gui_running')
    " win gvim does not like anyÃÅ
    set langmap=—éq,—ãk,—èy,—Éu,—å',–¥d,–ªl,–ºm,–±b,–∑z,—Ås,–æo,–µe,–∞a,—Är,–Ωn,–≤w,—áv,–πj,–øp,–∏i,–∂x,–∫c,—Çt,—Öh,–≥g,—Ñf,–ÆQ,–´K,–ØY,–£U,–¨\|,–îD,–õL,–úM,–ëB,–óZ,–°S,–ûO,–ïE,–êA,–†R,–ùN,–íW,–ßV,–ôJ,–üP,–òI,–ñX,–öC,–¢T,–•H,–ìG,–§F,‚Ññ#,‚ÇΩ$,—ä&,–™&,¬´{,‚Äû{,¬ª},‚Äú},—à[,–®[,—ë],–Å],—ç_,–≠_,—â\",–©\",—Ü^,–¶^
else
    set langmap=—éq,—ãk,—èy,—Éu,—å',–¥d,–ªl,–ºm,–±b,–∑z,—Ås,–æo,–µe,–∞a,—Är,–Ωn,–≤w,—áv,–πj,–øp,–∏i,–∂x,–∫c,—Çt,—Öh,–≥g,—Ñf,–ÆQ,–´K,–ØY,–£U,–¨\|,–îD,–õL,–úM,–ëB,–óZ,–°S,–ûO,–ïE,–êA,–†R,–ùN,–íW,–ßV,–ôJ,–üP,–òI,–ñX,–öC,–¢T,–•H,–ìG,–§F,‚Ññ#,‚ÇΩ$,—ä&,–™&,¬´{,‚Äû{,¬ª},‚Äú},ÃÅ`,—à[,–®[,—ë],–Å],—ç_,–≠_,—â\",–©\",—Ü^,–¶^
endif
"map <F10> :!xmodmap -e "keycode 105 = space"<cr><cr>
"map <S-F10> :!xmodmap -e "keycode 105 = Next"<cr><cr>

"map <S-F10> :!xmodmap -e "keycode 105 = Next"<cr><cr>
"map <F5> :!gcc -o `basename % .c` -Wall -O2 -march=i686 -ffast-math -lm %<cr>
"map <S-F5> :!gcc -o `basename % .c` -Wall -O2 -march=i686 -ffast-math -lm -lpthread %<cr>
"map <S-F10> :!g77 -Wall -O2 -march=i686 -ffast-math -lm -fno-fixed-form %<cr>
"map <S-F5> :!gcc -Wall -O2 -march=i686 -ffast-math -lm -lgsl -lgslcblas -lpthread %<cr>
"map <F5> :!i=%; make ${i\%.*}<cr>
"map <F5> :make `basename % .c`
"map <F5> :make `i=%; echo ${i\%.*}`<cr>

nmap <F1> :call ToggleLsp()<CR>
imap <F1> <ESC><F1>

nmap <F2> :call ToggleSyntax()<CR>
imap <F2> <ESC><F2>

nmap <S-F2> :call ToggleParenColors()<CR>
imap <S-F2> <ESC><S-F2>

nmap <F3> :call TogglePaste()<CR>
imap <F3> <ESC>:call TogglePaste()<CR>a

"Remove all trailing whitespace by pressing F4
nnoremap <F4> :let _s=@/<Bar>:%s/\s\+$//e<Bar>:let @/=_s<Bar><CR>
inoremap <F4> <ESC><F4>

" draw nice line for clarity on any command run:
set shell=~/bin/vim-shell-wrapper.sh
" then need to redefine shellpipe to restore redirection stderr also:
if has('unix')
    set shellpipe=2>&1\|\ tee"
endif

autocmd bufenter *.tex map <buffer> <F5> :update<CR>:!xelatex %<CR>
autocmd bufenter *.tex imap <buffer> <F5> <ESC><F5>
autocmd bufenter *.tex map <buffer> <F6> :update<CR>:!xelatex % && xdg-open %<.pdf<CR>
autocmd bufenter *.tex imap <buffer> <F6> <ESC><F6>

autocmd bufenter *.C map <buffer> <F6> :!root %<CR>
autocmd bufenter *.C imap <buffer> <F6> <ESC><F6>

autocmd bufenter *.py map <buffer> <F5> :update<CR>:!python3 -m py_compile %<cr>
autocmd bufenter *.py imap <buffer> <F5> <ESC><F5>
autocmd bufenter *.py map <buffer> <F6> :update<CR>:!python3 %<cr>
autocmd bufenter *.py imap <buffer> <F6> <ESC><F6>

map <F5> :update<CR>:make %<<CR>
imap <F5> <ESC><F5>
map <S-F5> :!strace ./%<<cr>
imap <S-F5> <ESC><S-F5>
map <F6> :update<CR>:!make %< && draw_line.sh running... && ./%<<cr>
imap <F6> <ESC><F6>
map <S-F6> :!time ./%<<cr>
imap <S-F6> <ESC><S-F6>
map <F7> :update<CR>:make<cr>
imap <F7> <ESC><F7>
autocmd bufenter *.tex map <buffer> <F8> :call SyncTex()<CR>
autocmd bufenter *.tex imap <buffer> <F8> <ESC><F8>
map <F9> :emenu SetSpell.<Tab>
map <F10> :emenu Encoding.<TAB>

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Lua settings
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
autocmd BufRead *.lua setlocal makeprg=lua\ %
autocmd BufRead *.lua setlocal efm=%s:\ %f:%l:%m

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"fortran settings
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
let fortran_more_precise=1
au! BufRead,BufNewFile *.f let b:fortran_do_enddo=1

"runtime! ftplugin/man.vim

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"C settings
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"iabbrev #d #define
"iabbrev #i #include <
"
"iabbrev #m int main ( int argc, char *argv[] )<cr>{<cr>}<esc>ko
"
"imap <C-l> <Esc>o{<CR>}<Esc>ko
"imap <C-b> <Space>(<Space><Space>)<Esc>hi


"map <F2> 
"au BufRead,BufNewFile *.c,*.h syn keyword cType real

au BufRead,BufNewFile *.c,*.h syn keyword cType cycles_t

"hi cStatement ctermfg=DarkGreen
hi PreProc ctermfg=DarkYellow
hi Constant ctermfg=DarkMagenta
"hi Constant ctermfg=Cyan
"hi cString ctermfg=Gray
"hi cNumber  ctermfg=Gray
"hi cFloat  ctermfg=Gray
hi Special ctermfg=DarkMagenta
"hi cFormat ctermfg=DarkGreen
hi Repeat ctermfg=DarkYellow
"hi Conditional ctermfg=DarkYellow
hi Operator ctermfg=DarkGreen
au BufRead,BufNewFile *.c,*.h syn keyword cop goto
"hi cop ctermfg=Cyan
hi Label ctermfg=Cyan
hi Comment ctermfg=DarkCyan
au BufRead,BufNewFile *.c,*.h syn match cBracketsf "\({\|}\)"
"hi cBracketsf ctermfg=DarkYellow
au BufRead,BufNewFile *.c,*.h syn match cBrackets "\((\|)\)"
hi def link Label Conditional
hi def link cLabel Conditional
"hi cBrackets ctermfg=Blue

"set cinoptions={1s,f1s  " whitesmith C style indentation

"fix colors in vimdiff
"hi DiffText   cterm=none ctermfg=Black ctermbg=Red gui=none guifg=Black guibg=Red
"hi DiffChange cterm=none ctermfg=Black ctermbg=LightMagenta gui=none guifg=Black guibg=LightMagenta
if &diff
    try
        colorscheme quiet
    catch /^Vim\%((\a\+)\)\=:E185/
        colorscheme evening
    endtry
endif

"set cinoptions+=f-2
"au BufRead,BufNewFile *.c,*.h set cino+=>2,e2
"au BufRead,BufNewFile *.C,*.cxx,*.cpp,*.cc,*.hh set cino+=>2,e2
"au BufRead,BufNewFile *.c,*.h imap , , 
"au BufRead,BufNewFile *.c,*.h imap { {<left><space><right><C-F>
"au BufRead,BufNewFile *.c,*.h imap <M-0> <space>(  )<left><left>
"au BufRead,BufNewFile *.c,*.h imap 0<Tab> (  )<left><left>
"au BufRead,BufNewFile *.c,*.h imap <M-9> <space>()
"au BufRead,BufNewFile *.c,*.h imap 9<Tab> <space>()
"au BufRead,BufNewFile *.c,*.h imap = =<left><space><right><space>
"au BufRead,BufNewFile *.c,*.h imap * *<left><space><right><space>
"au BufRead,BufNewFile *.c,*.h imap / /<left><space><right><space>
"au BufRead,BufNewFile *.c,*.h imap ( (  )<left><left>
"imap ( ()<left><left><space><right>
"imap <C-(> <(>

" * √ï√ã√Å√ö√Å√î√Ö√å√ò √â √ö√é√Å√ã √ï√ç√é√è√ñ√Ö√é√â√ë *
"au BufRead,BufNewFile *.c,*.h syn match cpointer "\*"
"au BufRead,BufNewFile *.c,*.h syn match cSign "\(\k\_s*\)\@<=\*"
"au BufRead,BufNewFile *.c,*.h syn match cSign "\([)\].]\_s*\)\@<=\*"
"au BufRead,BufNewFile *.c,*.h syn match cpointer "\(\(FILE\|char\|void\|int\|double\|float\|long\|sizeof\|_t\)\_s*\)\@<=\*"
"au BufRead,BufNewFile *.c,*.h syn match cpointer "\(struct\_s\_s*\k*\_s*\)\@<=\*"
"au BufRead,BufNewFile *.c,*.h syn match cpointer "\(const\_s\_s*\k*\_s*\)\@<=\*"
" √Ø√ì√î√Å√å√ò√é√ô√Ö √ö√é√Å√ã√â + - / %
"au BufRead,BufNewFile *.c,*.h syn match cSign "\(+\|\-\|/[*/]\@!\|%\)"

"√∫√é√Å√ã√â / *
au BufRead,BufNewFile *.c,*.h syn match cMultDivSign "\(/[*/]\@!\|\*\)"

" √Ø√ì√î√Å√å√ò√é√ô√Ö √ö√é√Å√ã√â + - %
au BufRead,BufNewFile *.c,*.h syn match cSign "\(+\|\-\|%\)"

" √∞√í√â√ì√ó√Å√â√ó√Å√é√â√ë = ++ -- += -= *= /= %= &= ^= |=
au BufRead,BufNewFile *.c,*.h syn match cSignEq "\(=\|++\|\-\-\|\([+\-*/%&^|]\)=\@=\)"
" √µ√ì√å√è√ó√â√ë || && == != ! >= <= > <
au BufRead,BufNewFile *.c,*.h syn match ccond "\(||\|&&\|==\|!=\|!\|>=\|<=\|>\|<\)"
" √∞√í√â√ì√ó√Å√â√ó√Å√é√â√ë >>= <<=
au BufRead,BufNewFile *.c,*.h syn match cSignEq "\(>>=\|<<=\)"
" √∫√é√Å√ã √ó√è√ê√í√è√ì√Å
au BufRead,BufNewFile *.c,*.h syn match cSignQ "\(?\|:\)"
" √µ√ã√Å√ö√Å√î√Ö√å√ò √é√Å √ì√î√í√ï√ã√î√ï√í√ï ->
au BufRead,BufNewFile *.c,*.h syn match cstructpointer "->"
hi cSign ctermfg=DarkCyan
hi cSignQ ctermfg=Yellow
hi cSignEq ctermfg=White
"hi cpointer ctermfg=Green
hi cMultDivSign ctermfg=Green
hi ccond ctermfg=DarkYellow
"au BufRead,BufNewFile *.c,*.h syn match cstructpointer "\(->\@=\|-\@<=>\)"
"au BufRead,BufNewFile *.c,*.h syn match cpointer "\(\([\/\*\-+=><!([;:,%&|?\n]\_s*\)\@<=\*\)"
"au BufRead,BufNewFile *.c,*.h syn match ccond "\(||\@=\||\@<=|\|&&\@=\|&\@<=&\|<\|>\|!\|==\@=\|=\@<==\|<\@<==\|>\@<==\|!\@<==\)" 
"au BufRead,BufNewFile *.c,*.h syn match cSignEq "\(=\|++\@=\|+\@<=+\|--\@=\|-\@<=-\|[-+*/]=\@=\)"
" √Æ√Ö √í√Å√Ç√è√î√Å√Ö√î:
"au BufRead,BufNewFile *.c,*.h syn match cpointer "\([;{}]\(\_k\|\_s\)*\)\@<=\*"
"au BufRead,BufNewFile *.c,*.h syn match cpointer "\([;{}]\(\_k\|\_s\)*\)\zs\*"

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"LaTeX
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

"au BufRead,BufNewFile *.tex set makeprg=latex

"map <F2> ?\\begin<cr>ma/\\end<cr>!'acat>_reg_vim.tex;cat _reg_vim.tex<cr>:!rm -f _reg_.dvi;latex _reg_.tex;xdvi _reg_<cr>

"map <F2> :call CopyTex()<cr>

"map <F2> ?\(\\begin\s*{\s*\(align\\|alignat\\|displaymath\\|eqnarray\\|equation\\|flalign\\|gather\\|math\\|multline\\|xalignat\)\*\=\s*}\\|\\[\\|\$\$\\|\$\\|\\(\)

"map  <F2> ?\(\\begin\s*{\s*\(align\\|alignat\\|displaymath\\|eqnarray\\|equation\\|flalign\\|gather\\|math\\|multline\\|xalignat\)\*\=\s*}\\|\\[\\|\$\$\\|\$\\|\\(\)<cr>v<right>/\(\\end\s*{\s*\(align\\|alignat\\|displaymath\\|eqnarray\\|equation\\|flalign\\|gather\\|math\\|multline\\|xalignat\)\*\=\s*}\\|\\]\\|\$\$\\|\$\\|\\)\)/e<cr>y:!echo >_reg_vim.tex<cr>:split _reg_vim.tex<cr>p:wq<cr>:!rm -f _reg_.dvi;latex _reg_.tex;dvipng _reg_.dvi;eog _reg_1.png&<cr><cr>
"map <F2> ?\\begin\s*{\s*\(align\\|alignat\\|displaymath\\|eqnarray\\|equation\\|flalign\\|gather\\|math\\|multline\\|xalignat\)\*\=\s*}<cr>v<right>/\\end\s*{\s*\(align\\|alignat\\|displaymath\\|eqnarray\\|equation\\|flalign\\|gather\\|math\\|multline\\|xalignat\)\*\=\s*}/e<cr>y:!echo >_reg_vim.tex<cr>:split _reg_vim.tex<cr>p:wq<cr>:!rm -f _reg_.dvi;latex _reg_.tex;dvipng _reg_.dvi;ee _reg_1.png&<cr><cr>

"function CopyTex_to_l()
"?\\begin\s*{\s*\(align\|alignat\|displaymath\|eqnarray\|equation\|flalign\|gather\|math\|multline\|xalignat\)\*\=\s*}
"normal v
"/\\end\s*{\s*\(align\|alignat\|displaymath\|eqnarray\|equation\|flalign\|gather\|math\|multline\|xalignat\)\*\=\s*}/e
"endfunction
function Copy_formula_to__part_vim_(outline)
let lnum=line(".")
let col=col(".")
if a:outline==1
	let @/='\\begin\s*{\s*\(align\|alignat\|displaymath\|eqnarray\|equation\|flalign\|gather\|math\|multline\|xalignat\)\*\=\s*}\|\\['
	normal N
	let currentchar=getline(".")[col(".") - 1]
	let nextchar=getline(".")[col(".")]
"	if currentchar=="\\"
		if nextchar=="b"
			let @/='\\end\s*{\s*\(align\|alignat\|displaymath\|eqnarray\|equation\|flalign\|gather\|math\|multline\|xalignat\)\*\=\s*}'
			normal vn
			let @/="}"
			normal n
		endif
"		if nextchar=="e"
"			let @/="}"
"			normal nv
"			let @/='\\begin\s*{\s*\(align\|alignat\|displaymath\|eqnarray\|equation\|flalign\|gather\|math\|multline\|xalignat\)\*\=\s*}'
"			normal N
"		endif
		if nextchar=="["
			let @/='\\]'
			normal vnl
		endif
"		if nextchar=="]"
"			normal lv
"			let @/='\\['
"			normal N
"		endif
"		if nextchar=="("
"			let @/='\\)'
"			normal vnl
"		endif
"	else
"		if currentchar=="\$"
"			if nextchar=="\$"
"				let @/='\$\$'
"				normal vnl
"			else
"				let @/='\$'
"				normal vn
"			endif
"		endif
"	endif
else
	let @/='\$\$\|\$\|\\('
	normal N
	let currentchar=getline(".")[col(".") - 1]
	let nextchar=getline(".")[col(".")]
	if currentchar=="\\"
		if nextchar=="("
			let @/='\\)'
			normal vnl
		endif
	else
		if nextchar=="\$"
			let @/='\$\$'
			normal vnl
		else
			let @/='\$'
			normal vn
		endif
	endif
endif
	
normal "ly
redir!>_part_vim_.tex
echo @l
redir END
call cursor(lnum, col)
endfunction

autocmd bufenter *.tex map <buffer> <F1> :call Copy_formula_to__part_vim_(1)<cr>:!rm -f _part_.dvi _part_1.png;
			\latex _part_.tex;dvipng _part_.dvi;ee _part_1.png&<cr><cr>
autocmd bufenter *.tex imap <buffer> <F1> <ESC>:<CR>l<F1>i
autocmd bufenter *.tex map <buffer> <S-F1> :call Copy_formula_to__part_vim_(0)<cr>:!rm -f _part_.dvi _part_1.png;
			\latex _part_.tex;dvipng _part_.dvi;ee _part_1.png&<cr><cr>
autocmd bufenter *.tex imap <buffer> <S-F1> <ESC>:<CR>l<S-F1>i
"map <F2>    ?\(\\begin\s*{\s*\(align\\|alignat\\|displaymath\\|eqnarray\\|
"			\equation\\|flalign\\|gather\\|math\\|multline\\|xalignat\)
"			\\*\=\s*}\\|\\[\\|\$\$\\|\$\\|\\(\)
"			\<cr>v<right>
"			\/\\end\s*{\s*\(align\\|alignat\\|displaymath\\|eqnarray\\|\equation
"			\\\|flalign\\|gather\\|math\\|multline\\|xalignat\)\*\=\s*}/e<cr>
"			\"ly:redir!>_reg_vim.tex<cr>:echo @l<cr>:redir END<cr>
"			\:!rm -f _reg_.dvi;rm -f _reg_1.png;latex _reg_.tex;dvipng _reg_.dvi;
"			\ee _reg_1.png&<cr><cr>
"map <F2>    ?\\begin\s*{\s*\(align\\|alignat\\|displaymath\\|eqnarray\\|
"			\equation\\|flalign\\|gather\\|math\\|multline\\|xalignat\)\*\=\s*}
"			\<cr>v<right>
"			\/\\end\s*{\s*\(align\\|alignat\\|displaymath\\|eqnarray\\|\equation
"			\\\|flalign\\|gather\\|math\\|multline\\|xalignat\)\*\=\s*}/e<cr>
"			\"ly:redir!>_reg_vim.tex<cr>:echo @l<cr>:redir END<cr>
"			\:!rm -f _reg_.dvi;latex _reg_.tex;dvipng _reg_.dvi;
"			\ee _reg_1.png&<cr><cr>
"map <S-F2> ?\(\\[\\|\$\$\\|\$\\|\\(\)<cr>v<right>/\(\\]\\|\$\$\\|\$\\|\\)\)/e<cr>y:!echo >_reg_vim.tex<cr>:split _reg_vim.tex<cr>p:wq<cr>:!rm -f _reg_.dvi;latex _reg_.tex;dvipng _reg_.dvi;eog _reg_1.png&<cr><cr>

"map  <F2> ?\(\\begin\s*{\s*\(align\\|alignat\\|displaymath\\|eqnarray\\|equation\\|flalign\\|gather\\|math\\|multline\\|xalignat\)\*\=\s*}\\|\\[\\|\$\\|\\(\)<cr>v/\(\\end\s*{\s*\(align\\|alignat\\|displaymath\\|eqnarray\\|equation\\|flalign\\|gather\\|math\\|multline\\|xalignat\)\*\=\s*}\\|\\]\\|\$\\|\\)\)/e<cr>y:!echo >_reg_vim.tex<cr>:split _reg_vim.tex<cr>p:wq<cr>:!rm -f _reg_.dvi;latex _reg_.tex;dvipng _reg_.dvi;display _reg_1.png&<cr><cr>

"map <F2> ?\(\\begin\s*{\s*\(align\\|alignat\\|displaymath\\|eqnarray\\|equation\\|flalign\\|gather\\|math\\|multline\\|xalignat\)\*\=\s*}\\|\\[\\|\$\$\\|\$\\|\\(\)
"map <S-F2> /\(\\end\s*{\s*\(align\\|alignat\\|displaymath\\|eqnarray\\|equation\\|flalign\\|gather\\|math\\|multline\\|xalignat\)\*\=\s*}\\|\\]\\|\$\$\\|\$\\|\\)\)/e

"map <F2> ?\(\\begin\s*{\s*\(align\\|alignat\\|displaymath\\|eqnarray\\|equation\\|flalign\\|gather\\|math\\|multline\\|xalignat\)\*\=\s*}\\|\\[\\|\$\$\\|\$\\|\\(\)<cr>v/\(\\end\s*{\s*\(align\\|alignat\\|displaymath\\|eqnarray\\|equation\\|flalign\\|gather\\|math\\|multline\\|xalignat\)\*\=\s*}\\|\\]\\|\$\$\\|\$\\|\\)\)<cr><left>/\(]\\|)\|\\|}\\|\$\)<cr>y:!echo >_reg_vim.tex<cr>:split _reg_vim.tex<cr>p:wq<cr>

"map <F2> ?\(\\begin\s*{\s*\(align\|alignat\|displaymath\|eqnarray\|equation\|flalign\|gather\|math\|multline\|xalignat\)\*\=\s*}\|\\[\|\$\$\|\$\)<cr>v/\(\\end\s*{\s*\(align\|alignat\|displaymath\|eqnarray\|equation\|flalign\|gather\|math\|multline\|xalignat\)\*\=\s*}\|\\]\|\$\$\|\$\)<cr>y:split _reg_vim.tex<cr>p:wq<cr>


autocmd bufenter *.tex set formatoptions-=tc
":set formatprg=par\ -80j
"enable hard wrap:
autocmd bufenter *.tex set textwidth=80
highlight OverLength ctermbg=DarkGrey guibg=DarkGrey
match OverLength /\%<81v.\%>80v/



" OPTIONAL: Starting with Vim 7, the filetype of empty .tex files defaults to
" 'plaintex' instead of 'tex', which results in vim-latex not being loaded.
" The following changes the default filetype back to 'tex':
let g:tex_flavor='latex'

"let g:Tex_ViewRule_pdf = 'evince_dbus.py'
"let g:Tex_ViewRule_pdf = 'python /usr/lib/x86_64-linux-gnu/gedit/plugins/synctex/evince_dbus.py'
"let g:Tex_DefaultTargetFormat = 'pdf'
"let g:Tex_CompileRule_pdf = 'xelatex --synctex=1 -interaction=nonstopmode $*'
function! SyncTex()
	let filename = bufname("%")
	let lineno = line(".")
	for syncfile in split(system('zgrep -l "' . filename . '" *.synctex.gz'), "\n")
		let pdffile = substitute(syncfile, ".synctex.gz$", ".pdf", "")
		exec 'silent ! python3 ~/bin/evince_dbus.py ' .
			\ '"' . pdffile . '" ' . lineno . ' "' . filename . '"'
	endfor
	redraw!
endfunction

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Pascal
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""


autocmd bufenter *.pas setlocal shiftwidth=2 softtabstop=2
"let g:pascal_delphi=1
au FileType pascal let g:pascal_fpc=1
au FileType pascal iabbrev b, begin
au FileType pascal iabbrev e, end
au FileType pascal iabbrev e. end;
au FileType pascal iabbrev w, writeln

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"OCaml
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

set ofu=syntaxcomplete#Complete
set runtimepath+=~/.opam/4.00.1/share/ocamlmerlin/vim
set runtimepath+=~/.opam/4.00.1/share/ocamlmerlin/vimbufsync
if filereadable("~/.opam/4.00.1/share/ocamlmerlin/vim/plugin/merlin.vim")
    source ~/.opam/4.00.1/share/ocamlmerlin/vim/plugin/merlin.vim
endif
if filereadable("~/.opam/4.01.0/share/ocamlmerlin/vim/plugin/merlin.vim")
    source ~/.opam/4.01.0/share/ocamlmerlin/vim/plugin/merlin.vim
endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Nim
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"autocmd bufenter *.nim map <F5> :update<CR>:!curnim c %<<cr>
"autocmd bufenter *.nim imap <F5> <ESC>:update<CR>:!curnim c %<<cr>

" nim.vim defines makeprg appropriately so just use :make
autocmd bufenter *.nim map <buffer> <F5> :update<CR>:make<cr>
autocmd bufenter *.nim imap <buffer> <F5> <ESC>:update<CR>:make<cr>
autocmd bufenter *.nim map <buffer> <F6> :update<CR>:!curnim c --hints:off -r %<<CR>
autocmd bufenter *.nim imap <buffer> <F6> <ESC><F6>
"autocmd bufenter *.nim filetype off
"autocmd bufenter *.nim filetype plugin indent on
fun! JumpToDef()
  if exists("*GotoDefinition_" . &filetype)
    call GotoDefinition_{&filetype}()
  else
    exe "norm! \<C-]>"
  endif
endf

" Jump to tag
nn <M-g> :call JumpToDef()<cr>
ino <M-g> <esc>:call JumpToDef()<cr>i
nn <C-g> :call JumpToDef()<cr>
ino <C-g> <esc>:call JumpToDef()<cr>i

" go next in popup window (my config reserves C-n for screen/tmux):
inoremap <expr><C-e> "\<C-n>"

nmap i <C-w>w
imap i <ESC>i

nmap w <Plug>(easymotion-bd-w)
imap w <ESC>w

" for vim-lsp
nmap f <Plug>(lsp-document-range-format)
imap f <ESC>f
vmap f <Plug>(lsp-document-range-format)

" apply fix from code suggestion
nmap a <Plug>(lsp-code-action)
imap a <ESC>a

nmap d <Plug>(lsp-peek-definition)
imap d <ESC>d
nmap g <Plug>(lsp-definition)
imap g <ESC>g

nmap l <Plug>(lsp-peek-declaration)
imap l <ESC>l

nmap r <Plug>(lsp-next-error)
imap r <ESC>r

nmap v <Plug>(lsp-next-reference)
imap v <ESC>v

nmap h <Plug>(lsp-type-hierarchy)
imap h <ESC>h

nmap s <Plug>(lsp-hover)
imap s <ESC>s

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" vim-slime plugin config
let g:slime_target = "tmux"
let g:slime_default_config = {"socket_name": "default", "target_pane": ":"}

" plugins path
set runtimepath+=~/activity-public/computer-program-data/vim/file-line/
set runtimepath+=~/activity-public/computer-program-data/vim/vim-signify/
set runtimepath+=~/activity-public/computer-program-data/vim/vim-easy-align/
set runtimepath+=~/activity-public/computer-program-data/vim/vim-easymotion/
set runtimepath+=~/activity-public/computer-program-data/vim/vim-signature/
let g:markbar_peekaboo_marks_to_display = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
let g:markbar_width = 40
let g:markbar_peekaboo_width = 40
nmap <Leader>o <Plug>ToggleMarkbar
"open quick mark bar
let g:markbar_peekaboo_apostrophe_mapping = 'm'
set runtimepath+=~/activity-public/computer-program-data/vim/vim-markbar/
set runtimepath+=~/activity-public/computer-program-data/vim/nim.vim/
"set runtimepath+=~/activity-public/computer-program-data/vim/nvim-vim/
set runtimepath+=~/activity-public/computer-program-data/vim/vim-noscrollbar/
set runtimepath+=~/activity-public/computer-program-data/vim/vim-ingo-library/
set runtimepath+=~/activity-public/computer-program-data/vim/vim-mark/

" Set ultisnips triggers
let g:UltiSnipsExpandTrigger="<tab>"
let g:UltiSnipsJumpForwardTrigger="<tab>"
let g:UltiSnipsJumpBackwardTrigger="<s-tab>"
set runtimepath+=~/activity-public/computer-program-data/vim/ultisnips/
let g:UltiSnipsSnippetDirectories = ["~/activity-public/computer-program-data/vim/vim-snippets/UltiSnips"]

let g:lsp_diagnostics_float_cursor = 1
set runtimepath+=~/activity-public/computer-program-data/vim/vim-lsp/
set runtimepath+=~/activity-public/computer-program-data/vim/asyncomplete.vim
set runtimepath+=~/activity-public/computer-program-data/vim/async.vim
set runtimepath+=~/activity-public/computer-program-data/vim/asyncomplete-lsp.vim

" disable :LspInstallServer suggestion:
let g:lsp_settings_enable_suggestions = 0
set runtimepath+=~/activity-public/computer-program-data/vim/vim-lsp-settings

set runtimepath+=~/activity-public/computer-program-data/vim/nimlsp

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" start interactive shell to use functions & aliases
"set shellcmdflag=-ic

"End of .vimrc
